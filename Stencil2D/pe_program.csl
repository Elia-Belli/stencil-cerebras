param memcpy_params: comptime_struct;

param pe_x: i16;
param pe_y: i16;
param kernel_dim_x: i16;
param kernel_dim_y: i16;

// Matrix dimensions
param M: i16;
param N: i16;
param iterations: i16;

param send_east_color: color;
param recv_west_color: color;

const send_east_oq = @get_output_queue(2);
const recv_west_iq = @get_input_queue(2);

// memcpy module provides infrastructure for copying data
// and launching functions from the host
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);


// 48 kB of global memory contain A
const n: i16 = (M+2)*(N+2);
var A: [n]f32;      // A is stored col major
var A_aux: [n]f32; 

var buffer_out_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{M} -> A[(i+2)*(N+2)-2]   });
var buffer_in_dsd =  @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{M} -> A[(i+1)*(N+2)] });

const out_dsd = @get_dsd(fabout_dsd, .{
  .extent = M,
  .fabric_color = send_east_color, 
  .output_queue = send_east_oq
});
const in_dsd = @get_dsd(fabin_dsd, .{
  .extent = M,
  .fabric_color = recv_west_color,
  .input_queue = recv_west_iq
});


// pointers
var A_ptr: [*]f32 = &A;
var A_aux_ptr: [*]f32 = &A_aux;
var temp: [*]f32;


fn stencil() void {
  
  for (@range(i16, 1, M+1, 1)) |i| {
    for (@range(i16, 1, N+1, 1)) |j| {
      A_aux_ptr[i*(N+2) + j] += A_ptr[(i-1)*(N+2) + j]
                              + A_ptr[(i+1)*(N+2) + j]
                              + A_ptr[i*(N+2) + (j-1)]
                              + A_ptr[i*(N+2) + (j+1)]
                              - 4.0*A_ptr[i*(N+2) + j];
    }
  }
}

fn send_right() void {
  @fmovs(out_dsd, buffer_out_dsd, .{ .async = true});
  //@fmovs(out_dsd, buffer_out_dsd, .{ .async = true, .activate = stencil_task_id});
}

fn recv_left() void {
  @fmovs(buffer_in_dsd, in_dsd, .{ .async = true});
  //@fmovs(buffer_in_dsd, in_dsd, .{ .async = true, .activate = stencil_task_id});
}

fn compute() void {
  
  // initialize A_aux
  for (@range(i16, n)) |i| {
    A_aux[i] = 0.0;
  }

  for (@range(i16, iterations)) |iter| {
    // exchange halo with other PEs  
    if(pe_x != kernel_dim_x -1) {
      send_right();
    }
    if(pe_x != 0) {
      recv_left();
    }

    stencil();

    // swap A and A_aux
    temp = A_ptr;
    A_ptr =  A_aux_ptr;
    A_aux_ptr = temp;
  }

  sys_mod.unblock_cmd_stream();
}

comptime {
  //@bind_local_task(stencil, stencil_task_id);

  @export_symbol(A_ptr, "A");
  @export_symbol(compute, "compute");
}
